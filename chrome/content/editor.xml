<?xml version="1.0"?>
<bindings id="handyClicks-bindings" xmlns="http://www.mozilla.org/xbl">
	<binding id="codeEditor" extends="chrome://global/content/bindings/textbox.xml#textarea">
		<implementation>
			<field name="tabSymbol">handyClicksPrefUtils.pref("editor.tabSymbol") || "\t";</field>
			<property name="editor" readonly="true">
				<getter>
					return this.inputField // Thanks to Custom Buttons!
						.QueryInterface(Components.interfaces.nsIDOMNSEditableElement)
						.editor
						.QueryInterface(Components.interfaces.nsIPlaintextEditor);
				</getter>
			</property>
			<property name="newValue">
				<setter>
					this.value = val;
					this.editor.transactionManager.clear();
				</setter>
			</property>
			<method name="cmdInsert">
				<parameter name="text" />
				<body>
					this.editor.insertText(text);
				</body>
			</method>
			<method name="insertText">
				<parameter name="text" />
				<parameter name="startPos" />
				<parameter name="endPos" />
				<parameter name="selectFlag" />
				<parameter name="selStart" />
				<parameter name="selEnd" />
				<body>
				<![CDATA[
					var ifi = this.inputField;

					var sTop = ifi.scrollTop;
					var sHeight = ifi.scrollHeight;
					var sLeft = ifi.scrollLeft;
					// var sWidth = ifi.scrollWidth;

					ifi.selectionStart = startPos;
					ifi.selectionEnd = endPos;

					this.cmdInsert(text);

					switch(selectFlag) {
						case 0: // select all
							ifi.selectionStart = startPos;
							ifi.selectionEnd = startPos + text.length;
						break;
						case 1: // move cursor to start
							ifi.selectionStart = startPos;
							ifi.selectionEnd = startPos;
						break;
						case 2: // custom selection
							ifi.selectionStart = selStart;
							ifi.selectionEnd = selEnd;
					}
					ifi.scrollTop = sTop + (ifi.scrollHeight - sHeight);
					ifi.scrollLeft = sLeft; // + (ifi.scrollWidth - sWidth);
				]]>
				</body>
			</method>
			<method name="setIndent">
				<parameter name="indentChar" />
				<parameter name="removeFlag" />
				<body>
				<![CDATA[
					var val = this.value;
					var ifi = this.inputField;

					var startPos = ifi.selectionStart;
					var endPos = ifi.selectionEnd;

					var sel = val.substring(startPos, endPos);
					if(!/\n|\r/.test(sel)) {
						if(removeFlag)
							this.insertText(indentChar, startPos, endPos, 1);
						else
							this.cmdInsert(indentChar);
						return;
					}
					var startVal = val.substring(0, startPos);
					var endVal = val.substring(endPos, val.length);

					var selLen = endPos - startPos;
					var startLine = startVal.search(/(^|\n|\r)[^\n\r]*$/);
					startLine += RegExp.$1.length;
					var endLine = startVal.length + selLen + endVal.search(/\r|\n|$/);

					var block = val.substring(startLine, endLine);
					if(removeFlag) {
						if(/^ {2,}$/.test(indentChar))
							indentChar = "( {1," + indentChar.length + "}|\\t)";
						var re = new RegExp("^" + indentChar, "mg");
						if(re.test(block))
							block = block.replace(re, "");
						else
							return;
					}
					else
						block = block.replace(/^/mg, indentChar);
					this.insertText(block, startLine, endLine, 0);
				]]>
				</body>
			</method>
			<method name="toggleComments">
				<parameter name="onlyInLineStart" />
				<body>
				<![CDATA[
					var val = this.value;
					var ifi = this.inputField;

					var startPos = ifi.selectionStart;
					var endPos = ifi.selectionEnd;

					var sel = val.substring(startPos, endPos);
					var isMultiline = /\n|\r/.test(sel);

					var startVal = val.substring(0, startPos);
					var endVal = val.substring(endPos, val.length);

					var selLen = endPos - startPos;
					var startLine = startVal.search(/(^|\n|\r)[^\n\r]*$/);
					startLine += RegExp.$1.length;
					var endLine = startVal.length + selLen + endVal.search(/\r|\n|$/);

					var block = val.substring(startLine, endLine);
					var bLen0 = block.length;

					if(onlyInLineStart)
						var re = /^\/\//mg, subst = "";
					else
						var re = /^(\s*)\/\//mg, subst = "$1";
					if(re.test(block))
						block = block.replace(re, subst);
					else
						block = block.replace(/^/mg, "//");
					var bLen1 = block.length;

					if(isMultiline)
						this.insertText(block, startLine, endLine, 0);
					else
						this.insertText(block, startLine, endLine, 2, startPos + bLen1 - bLen0, endPos + bLen1 - bLen0);
				]]>
				</body>
			</method>
			<method name="formatNewLine">
				<body>
				<![CDATA[
					var val = this.value;
					var ifi = this.inputField;

					var startPos = ifi.selectionStart;
					var endPos = ifi.selectionEnd;

					var startVal = val.substring(0, startPos);
					var endVal = val.substring(endPos, val.length);

					var startLine = startVal.search(/(^|\n|\r)[^\n\r]*$/);
					startLine += RegExp.$1.length;

					var line = val.substring(startLine, startPos);

					var indent = /^([ \t]+)/.test(line) ? RegExp.$1 : "";
					this.cmdInsert("\n" + indent);
				]]>
				</body>
			</method>
			<method name="goToLine">
				<body>
				<![CDATA[
					var ps = Components.classes["@mozilla.org/embedcomp/prompt-service;1"]
						.getService(Components.interfaces.nsIPromptService);
					var curNum = this.value.substring(0, this.inputField.selectionStart).match(/^.*$/mg).length;
					var num = { value: curNum };
					var ut = "handyClicksUtils" in window && handyClicksUtils;
					var res = ps.prompt(
						window,
						ut ? ut.getLocalized("goToLineTitle") : "Go to line\u2026",
						(ut ? ut.getLocalized("goToLineMessage") : "Line number (1 \u2026 %max):")
							.replace("%max", this.linesCount),
						num,
						null, {}
					);
					num = parseInt(num.value);
					if(isFinite(num))
						this.scrollTo(num, true);
				]]>
				</body>
			</method>
			<property name="linesCount" readonly="true">
				<getter>
				<![CDATA[
					return this.editor.rootElement.getElementsByTagName("br").length;
				]]>
				</getter>
			</property>
			<method name="scrollTo">
				<parameter name="lineNumber" />
				<parameter name="allowOverflow" />
				<body>
				<![CDATA[
					// Thanks to Custom Buttons!
					var editor = this.editor;
					var maxNumber = this.linesCount;
					var overflow = lineNumber > maxNumber;
					if(overflow && !allowOverflow)
						editor.endOfDocument();
					else {
						if(overflow)
							lineNumber = maxNumber;
						editor.beginningOfDocument();
						var sc = editor.selectionController;
						while(--lineNumber > 0)
							sc.lineMove(true, false);
					}
					this.scrollSelectionIntoView();
					this.focus();
				]]>
				</body>
			</method>
			<method name="selectLine">
				<parameter name="lineNumber" />
				<parameter name="allowOverflow" />
				<body>
				<![CDATA[
					// Thanks to Custom Buttons!
					this.scrollTo(lineNumber, allowOverflow);
					this.editor.selectionController.intraLineMove(true, true);
					this.focus();
				]]>
				</body>
			</method>
			<method name="scrollSelectionIntoView">
				<body>
				<![CDATA[
					// Thanks to Custom Buttons!
					try {
						var sc = Components.interfaces.nsISelectionController;
						this.editor.selectionController.scrollSelectionIntoView(
							sc.SELECTION_NORMAL,
							sc.SELECTION_ANCHOR_REGION,
							true
						);
					}
					catch(e) {}
				]]>
				</body>
			</method>
			<property name="maximized">
				<getter>
				<![CDATA[
					return this.getAttribute("hc_maximized") == "true";
				]]>
				</getter>
				<setter>
				<![CDATA[
					this.setAttribute("hc_maximized", !val);
					this.toggleMaximized();
				]]>
				</setter>
			</property>
			<method name="toggleMaximized">
				<body>
				<![CDATA[
					var mm = this.maximized;
					var node = this;
					while(node && "setAttribute" in node) {
						if(mm) node.removeAttribute("hc_maximized");
						else   node.setAttribute("hc_maximized", "true");
						node = node.parentNode;
					}
				]]>
				</body>
			</method>
			<method name="moveCaret">
				<parameter name="moveLeft" />
				<parameter name="event" />
				<body>
				<![CDATA[
					var ifi = this.inputField;
					var ss = ifi.selectionStart;
					var se = ifi.selectionEnd;
					if(ss == se)
						return;
					event.preventDefault();
					if(moveLeft)
						ifi.selectionStart = ifi.selectionEnd = ss;
					else
						ifi.selectionStart = ifi.selectionEnd = se;
				]]>
				</body>
			</method>
			<method name="textZoom">
				<parameter name="add" />
				<body>
				<![CDATA[
					this.style.fontSize = add == 0
						? ""
						: Math.min(
							Math.max(
								parseInt(this.ownerDocument.defaultView.getComputedStyle(this, "").fontSize) + add,
								2
							),
							36
						) + "px";
				]]>
				</body>
			</method>
		</implementation>
		<handlers>
			<handler event="keypress" preventdefault="true" keycode="VK_TAB" action="this.setIndent(this.tabSymbol, false);" />
			<handler event="keypress" preventdefault="true" keycode="VK_TAB" action="this.setIndent(this.tabSymbol, true);" modifiers="shift" />
			<handler event="keypress" preventdefault="true" key=" " action="this.setIndent(' ', false);" />
			<handler event="keypress" preventdefault="true" key=" " action="this.setIndent(' ', true);" modifiers="shift" />
			<handler event="keypress" preventdefault="true" key="a" action="this.toggleComments(true);" modifiers="control,shift" />
			<handler event="keypress" preventdefault="true" key="q" action="this.toggleComments(false);" modifiers="control,shift" />
			<handler event="keypress" preventdefault="true" keycode="VK_RETURN" action="this.formatNewLine();" />
			<handler event="keypress" preventdefault="true" keycode="VK_F12" action="this.toggleMaximized();" />
			<handler event="keypress" keycode="VK_LEFT" action="this.moveCaret(true, event);" />
			<handler event="keypress" keycode="VK_RIGHT" action="this.moveCaret(false, event);" />
			<handler event="keypress" preventdefault="true" key="+" action="this.textZoom(1);" modifiers="control" />
			<handler event="keypress" preventdefault="true" key="-" action="this.textZoom(-1);" modifiers="control" />
			<handler event="keypress" preventdefault="true" key="0" action="this.textZoom(0);" modifiers="control" />
			<handler event="keypress" preventdefault="true" key="G" action="this.goToLine();" modifiers="control" />
			<handler event="blur">
			<![CDATA[
				if(event.originalTarget !== this.inputField || !this.maximized)
					return;
				setTimeout(function(_this) {
					if(document.commandDispatcher.focusedElement !== _this.inputField)
						_this.maximized = false;
				}, 0, this);
			]]>
			</handler>
		</handlers>
	</binding>
</bindings>