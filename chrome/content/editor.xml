<?xml version="1.0"?>
<bindings id="handyClicks-bindings" xmlns="http://www.mozilla.org/xbl">
	<binding id="codeEditor" extends="chrome://global/content/bindings/textbox.xml#textarea">
		<implementation>
			<constructor>
			<![CDATA[
				var ww = -1;
				if(this.hasAttribute("hc_wrapWidth")) {
					var _ww = Number(this.getAttribute("hc_wrapWidth"));
					if(isFinite(_ww))
						ww = _ww;
				}
				try { // Strange bug in Firefox 1.5
					this.editor.wrapWidth = ww;
				}
				catch(e) {
				}
				if("MozTabSize" in this.style) {
					var top = window.top;
					var pu = "handyClicksPrefUtils" in top && top.handyClicksPrefUtils;
					if(pu) {
						this.style.MozTabSize = Math.max(1, Math.min(24, pu.pref("editor.tabSize")));
						pu.oSvc.addObserver(function(pName, pVal) {
							if(pName == "editor.tabSize")
								this.style.MozTabSize = Math.max(1, Math.min(24, pVal));
						}, this);
					}
				}
			]]>
			</constructor>
			<property name="tabSymbol">
				<getter>
				<![CDATA[
					return this.getAttribute("hc_tabSymbol")
						|| "handyClicksPrefUtils" in top && top.handyClicksPrefUtils.pref("editor.tabSymbol")
						|| "\t";
				]]>
				</getter>
				<setter>
					this.setAttribute("hc_tabSymbol", val);
				</setter>
			</property>
			<property name="editor" readonly="true">
				<getter>
					return this.inputField // Thanks to Custom Buttons!
						.QueryInterface(Components.interfaces.nsIDOMNSEditableElement)
						.editor
						.QueryInterface(Components.interfaces.nsIPlaintextEditor);
				</getter>
			</property>
			<property name="newValue">
				<setter>
					this.value = val;
					this.editor.transactionManager.clear();
				</setter>
			</property>
			<method name="insertText">
				<parameter name="text" />
				<parameter name="noScroll" />
				<parameter name="select" />
				<body>
				<![CDATA[
					if(noScroll) {
						var ifi = this.inputField;
						var sTop    = ifi.scrollTop;
						var sHeight = ifi.scrollHeight;
						var sLeft   = ifi.scrollLeft;
						var sWidth  = ifi.scrollWidth;
					}

					if(text)
						this.editor.insertText(text);
					else
						this.editor.deleteSelection(0);

					if(noScroll) {
						ifi.scrollTop  = sTop  + (ifi.scrollHeight - sHeight);
						ifi.scrollLeft = sLeft + (ifi.scrollWidth  - sWidth);
					}
					if(select)
						this.inputField.selectionStart -= text.length;
				]]>
				</body>
			</method>
			<method name="setIndent">
				<parameter name="indentChar" />
				<parameter name="removeFlag" />
				<body>
				<![CDATA[
					var val = this.value;
					var ifi = this.inputField;
					var ss = ifi.selectionStart;
					var se = ifi.selectionEnd;

					var sel = val.substring(ss, se);
					var lineStart = val.substring(0, ss).match(/[^\r\n]*$/)[0];
					var lineEnd = val.substring(se).match(/^[^\r\n]*/)[0];

					if(!/\n|\r/.test(sel)) {
						if(/^ {2,}$/.test(indentChar)) {
							var lenStart = lineStart.length + lineEnd.match(/^ */)[0].length;
							var maxSpaces = indentChar.length;
							indentChar = indentChar.substr(0, (maxSpaces - lenStart % maxSpaces) || maxSpaces);
						}
						this.insertText(indentChar);
						if(removeFlag)
							ifi.selectionStart = ifi.selectionEnd = ss;
						return;
					}

					var block = lineStart + sel + lineEnd;
					if(removeFlag) {
						if(/^ {2,}$/.test(indentChar))
							indentChar = "( {1," + indentChar.length + "}|\\t)";
						var re = new RegExp("^" + indentChar, "mg");
						if(!re.test(block))
							return;
						block = block.replace(re, "");
					}
					else {
						block = block.replace(/^/mg, indentChar);
					}

					ifi.selectionStart = ss - lineStart.length;
					ifi.selectionEnd   = se + lineEnd.length;
					this.insertText(block, true, true);
				]]>
				</body>
			</method>
			<field name="_allowBackspace">false</field>
			<method name="removeSpaces">
				<parameter name="event" />
				<body>
				<![CDATA[
					if(this._allowBackspace)
						return;
					var ifi = this.inputField;
					var ss = ifi.selectionStart;
					var se = ifi.selectionEnd;
					if(ss != se)
						return;
					var tab = this.tabSymbol;
					if(!/^ {2,}$/.test(tab))
						return;
					var line = this.value.substring(0, ss).match(/[^\r\n]*$/)[0];
					var availSpaces = line.match(/ *$/)[0].length;
					if(availSpaces <= 1)
						return;
					var maxSpaces = line.length % tab.length || tab.length;
					var removeSpaces = Math.min(availSpaces, maxSpaces);

					this._allowBackspace = true;
					while(--removeSpaces) {
						var evt = document.createEvent("KeyEvents");
						evt.initKeyEvent(
							event.type,
							event.bubbles, event.cancelable, event.view,
							event.ctrlKey, event.altKey, event.shiftKey, event.metaKey,
							event.keyCode, event.charCode
						);
						event.originalTarget.dispatchEvent(evt);
					}
					this._allowBackspace = false;
				]]>
				</body>
			</method>
			<method name="toggleComments">
				<parameter name="onlyInLineStart" />
				<body>
				<![CDATA[
					var val = this.value;
					var ifi = this.inputField;
					var ss = ifi.selectionStart;
					var se = ifi.selectionEnd;

					var sel = val.substring(ss, se);

					var lineStart = val.substring(0, ss).match(/[^\r\n]*$/)[0];
					var lineEnd = val.substring(se).match(/^[^\r\n]*/)[0];
					var block = lineStart + sel + lineEnd;

					if(onlyInLineStart) {
						var re = /^\/\//mg;
						var subst = "";
					}
					else {
						var re = /^(\s*)\/\//mg;
						var subst = "$1";
					}
					var comment = "//";
					var hasComments = re.test(block);
					block = hasComments
						? block.replace(re, subst)
						: block.replace(/^/mg, comment);

					ifi.selectionStart = ss - lineStart.length;
					ifi.selectionEnd   = se + lineEnd.length;
					if(/\n|\r/.test(sel))
						this.insertText(block, true, true);
					else {
						this.insertText(block, true, false);
						var dl = (hasComments ? -1 : 1)*comment.length;
						ifi.selectionStart = Math.max(ss + dl, ss - lineStart.length);
						ifi.selectionEnd   = se + dl;
					}
				]]>
				</body>
			</method>
			<method name="formatNewLine">
				<body>
				<![CDATA[
					var line = this.value.substring(0, this.inputField.selectionStart).match(/[^\r\n]*$/)[0];
					var indent = /^[ \t]+/.test(line) ? RegExp.lastMatch : "";
					this.insertText("\n" + indent);
				]]>
				</body>
			</method>
			<method name="goToLine">
				<body>
				<![CDATA[
					var currLine = this.currentLine;
					var currCol  = this.currentColumn;
					var num = { value: currLine + ":" + currCol };
					var ut = "handyClicksUtils" in top && top.handyClicksUtils;
					var ps = Components.classes["@mozilla.org/embedcomp/prompt-service;1"]
						.getService(Components.interfaces.nsIPromptService);
					var res = ps.prompt(
						top,
						ut ? ut.getLocalized("goToLineTitle") : "Go to line\u2026",
						(ut ? ut.getLocalized("goToLineMessage") : "Line number (1 \u2026 %max):")
							.replace("%max", this.linesCount),
						num,
						null, {}
					);
					if(!res)
						return;
					if(!/^(\+|-)?(\d+)(?:\s*[^\d+-]+\s*(\+|-)?(\d+))?$/.test(num.value))
						return;
					var line = Number(RegExp.$2);
					var col  = Number(RegExp.$4);
					if(RegExp.$1)
						line = Math.max(1, currLine + line*(RegExp.$1 == "+" ? 1 : -1));
					if(RegExp.$3)
						col  = Math.max(1, currCol  + col *(RegExp.$3 == "+" ? 1 : -1));
					if(line == currLine && col == currCol)
						return;
					this.scrollTo(line, col);
				]]>
				</body>
			</method>
			<property name="currentLine" readonly="true">
				<getter>
				<![CDATA[
					return this.value.substring(0, this.inputField.selectionStart).match(/^.*$/mg).length;
				]]>
				</getter>
			</property>
			<property name="linesCount" readonly="true">
				<getter>
				<![CDATA[
					return this.editor.rootElement.getElementsByTagName("br").length;
				]]>
				</getter>
			</property>
			<property name="currentColumn" readonly="true">
				<getter>
				<![CDATA[
					return this.value.substring(0, this.inputField.selectionStart).match(/[^\n\r]*$/)[0].length + 1;
				]]>
				</getter>
			</property>
			<property name="columnsCount" readonly="true">
				<getter>
				<![CDATA[
					// For current line
					var ifi = this.inputField;
					var ss = ifi.selectionStart;
					var se = ifi.selectionEnd;
					var val = this.value;
					return val.substring(0, ss).match(/[^\n\r]*$/)[0].length
						+ val.substring(ss).match(/^[^\n\r]*/)[0].length
						+ 1;
				]]>
				</getter>
			</property>
			<method name="scrollTo">
				<parameter name="lineNumber" />
				<parameter name="columnNumber" />
				<parameter name="allowOverflow" />
				<body>
				<![CDATA[
					if(allowOverflow === undefined)
						allowOverflow = true;
					// Thanks to Custom Buttons!
					if(lineNumber != null && isFinite(lineNumber)) {
						var editor = this.editor;
						var maxLine = this.linesCount;
						if(lineNumber > maxLine && !allowOverflow)
							editor.endOfDocument();
						else {
							lineNumber = Math.min(lineNumber, maxLine);
							editor.beginningOfDocument();
							var sc = editor.selectionController;
							while(--lineNumber > 0)
								sc.lineMove(true, false);
						}
					}
					if(columnNumber != null && isFinite(columnNumber)) {
						var maxCol = this.columnsCount;
						columnNumber = Math.max(1, Math.min(maxCol, columnNumber));
						var ifi = this.inputField;
						ifi.selectionStart = ifi.selectionEnd = ifi.selectionStart - this.currentColumn + columnNumber;
					}
					this.scrollSelectionIntoView();
					this.focus();
				]]>
				</body>
			</method>
			<method name="selectLine">
				<parameter name="lineNumber" />
				<body>
				<![CDATA[
					// Thanks to Custom Buttons!
					this.scrollTo(lineNumber, null, false);
					this.editor.selectionController.intraLineMove(true, true);
					this.focus();
				]]>
				</body>
			</method>
			<method name="scrollSelectionIntoView">
				<body>
				<![CDATA[
					// Thanks to Custom Buttons!
					try {
						var sc = this.editor.selectionController;
						sc.scrollSelectionIntoView(
							sc.SELECTION_NORMAL,
							sc.SELECTION_ANCHOR_REGION,
							true
						);
					}
					catch(e) {
					}
				]]>
				</body>
			</method>
			<property name="maximized">
				<getter>
				<![CDATA[
					return this.getAttribute("hc_maximized") == "true";
				]]>
				</getter>
				<setter>
				<![CDATA[
					var node = this;
					for(; node && "setAttribute" in node; node = node.parentNode) {
						if(val) node.setAttribute("hc_maximized", "true");
						else    node.removeAttribute("hc_maximized");
					}
				]]>
				</setter>
			</property>
			<method name="toggleMaximized">
				<body>
				<![CDATA[
					this.maximized = !this.maximized;
				]]>
				</body>
			</method>
			<method name="textZoom">
				<parameter name="add" />
				<body>
				<![CDATA[
					this.style.fontSize = add == 0
						? ""
						: Math.min(
							36,
							Math.max(
								1,
								parseInt(this.ownerDocument.defaultView.getComputedStyle(this, null).fontSize) + add
							)
						) + "px";
					this.id && document.persist(this.id, "style");
				]]>
				</body>
			</method>
			<method name="toggleWordWrap">
				<body>
				<![CDATA[
					var ww = this.getAttribute("hc_wrapWidth") == "0" ? -1 : 0;
					this.editor.wrapWidth = ww;
					this.setAttribute("hc_wrapWidth", ww);
					this.id && document.persist(this.id, "hc_wrapWidth");
				]]>
				</body>
			</method>

			<field name="_tempFile">null</field>
			<method name="openExternalEditor">
				<body>
				<![CDATA[
					if(!("handyClicksUtils" in top))
						return;
					var ut = top.handyClicksUtils;
					var file = this._tempFile;
					var isNew = !file || !file.exists();

					var ext = ut.pu.pref("editor.externalEditorExtension") || "js";
					if(isNew) {
						var fName = "handyclicks_" + this.id.replace(/^hc-editor-|Field/g, "") + "." + ext;
						file = ut.getFileByAlias("TmpD");
						file.append(fName);
						file.createUnique(file.NORMAL_FILE_TYPE, 0644);
						this._tempFile = file;

						Components.classes["@mozilla.org/uriloader/external-helper-app-service;1"]
							.getService(Components.interfaces.nsPIExternalAppLauncher)
							.deleteTemporaryFileOnExit(file);
					}

					ut.writeToFile(ut.platformLineBreaks(this.value), file);

					if(isNew) {
						this._lastModifiedTime = file.lastModifiedTime;
						this._fileSize = file.fileSize;

						var _this = this;
						var upd = function(e) {
							var file = _this._tempFile;
							if(!file || !file.exists())
								return;
							var fTime = file.lastModifiedTime;
							var fSize = file.fileSize;
							if(fTime == _this._lastModifiedTime && fSize == _this._fileSize)
								return;
							var fVal = ut.readFromFile(file).replace(/\r\n?|\n\r?/g, "\n");
							if(fVal == _this.value) {
								_this._lastModifiedTime = fTime;
								_this._fileSize = fSize;
								return;
							}

							var ifi = _this.inputField;
							var sTop = ifi.scrollTop;
							var sLeft = ifi.scrollLeft;

							_this.value = fVal;

							ifi.scrollTop = sTop;
							ifi.scrollLeft = sLeft;

							_this._lastModifiedTime = fTime;
							_this._fileSize = fSize;
							_this.fade();

							_this.fireChange();
						};
						top.addEventListener("focus", upd, false);
						top.addEventListener("unload", function _unl(e) {
							var win = e.target.defaultView;
							if(win !== win.top)
								return;
							win.removeEventListener(e.type, _unl, false);
							win.removeEventListener("focus", upd, false);
							var file = _this._tempFile;
							if(file && file.exists())
								file.remove(false);
						}, false);
					}

					var ee = ut.pu.pref("editor.externalEditorPath");

					if(!ee && "nsIWindowsRegKey" in Components.interfaces) try {
						// Check Windows association
						var extKey = Components.classes["@mozilla.org/windows-registry-key;1"]
							.createInstance(Components.interfaces.nsIWindowsRegKey);
						var hkcr = extKey.ROOT_KEY_CLASSES_ROOT;
						var accr = extKey.ACCESS_READ;
						extKey.open(hkcr, "." + ext, accr);
						var cmdId = extKey.readStringValue("");
						extKey.close();
						if(cmdId) {
							var cmdKey = Components.classes["@mozilla.org/windows-registry-key;1"]
								.createInstance(Components.interfaces.nsIWindowsRegKey);
							cmdKey.open(hkcr, cmdId + "\\shell\\open\\command", accr);
							var cmd = cmdKey.readStringValue("");
							cmdKey.close();
							if(cmd) {
								// %SystemRoot%\System32\WScript.exe "%1" %*
								cmd = ut.expandEnvironmentVariables(cmd);
								var wscript = ut.expandEnvironmentVariables("%SystemRoot%\\system32\\wscript.exe");
								var indx = cmd.toLowerCase().indexOf(wscript.toLowerCase());
								if(indx == 0 || indx == 1)
									ee = "%SystemRoot%\\notepad.exe";
							}
						}
					}
					catch(e) {
					}

					if(ee) {
						var args = [file.path];
						var eeArgs = ut.pu.pref("editor.externalEditorArgs");
						if(eeArgs)
							args.push(eeArgs.replace("%L", this.currentLine));
						if(ut.startProcess(ee, args))
							this.fade();
					}
					else {
						//~ todo: association may be "invalid" (like wscript.exe on Windows) or missing
						try {
							file.launch();
							this.fade();
						}
						catch(e) { // See https://developer.mozilla.org/en/nsILocalFile#Remarks
							ut._err(e);
						}
					}
				]]>
				</body>
			</method>

			<field name="_fadeTimeout">null</field>
			<method name="fade">
				<body>
				<![CDATA[
					// opacity: opMax ... opMin ... opMax
					const opMax = 1;
					const opMin = 0.42;
					const opDur = 400;
					const opDelay = 5;

					if(this._fadeTimeout)
						clearTimeout(this._fadeTimeout);

					var endTime = Date.now() + opDur;
					var stl = this.style;
					this._fadeTimeout = setTimeout(function(_this) {
						var remTime = endTime - Date.now();
						if(remTime < 0) {
							stl.removeProperty("opacity");
							_this._fadeTimeout = null;
							return;
						}
						var op = opMin + Math.abs((remTime - opDur/2) * (opMax - opMin) / (opDur/2));
						stl.setProperty("opacity", op, "important");
						_this._fadeTimeout = setTimeout(arguments.callee, opDelay, this);
					}, opDelay, this);
				]]>
				</body>
			</method>

			<method name="jsAutocomplete">
				<parameter name="reverseFlag" />
				<body>
				<![CDATA[
					var ifi = this.inputField;
					var ss = ifi.selectionStart;
					var se = ifi.selectionEnd;
					var val = this.value;
					var selText = val.substring(ss, se);
					if(selText && !/^[\w$]+['"]?$/.test(selText))
						return;
					var startText = val.substring(0, ss);

					if(!/(?:(\.)\s*|('|"))?([\w$]+)$/.test(startText))
						return;
					var isProp = !!RegExp.$1;
					var isStr = !!RegExp.$2, strComma = RegExp.$2;
					var lastWord = RegExp.$3;

					var scopeProp = isProp
						? "jsProps"
						: isStr
							? "jsStrings"
							: "jsStatements";

					var newWord;
					var curWordOrig = lastWord + selText;
					var curWord = curWordOrig.replace(/['"]$/, "");

					if(!("handyClicksAutocompleteData" in top)) {
						Components.classes["@mozilla.org/moz/jssubscript-loader;1"]
							.getService(Components.interfaces.mozIJSSubScriptLoader)
							.loadSubScript(new Error().fileName.replace(/[^\/]+$/, "") + "editorAutocompleteData.js");
					}
					var scopeArr = top.handyClicksAutocompleteData[scopeProp];
					if(reverseFlag)
						scopeArr = scopeArr.reverse();

					var found = false;
					scopeArr.some(function(p) {
						if(!found && p == curWord) {
							found = true;
							return false;
						}
						if(found && p.indexOf(lastWord) == 0)
							return newWord = p;
						return false;
					});
					!newWord && scopeArr.some(function(p) {
						if(p.indexOf(lastWord) == 0)
							return newWord = p;
						return false;
					});
					if(!newWord || newWord == curWord)
						return;

					var cnt = 0;
					scopeArr.forEach(function(p) {
						if(p.indexOf(lastWord) == 0)
							cnt++;
					});

					if(isStr)
						newWord += strComma;

					var sPos = startText.lastIndexOf(lastWord);
					ifi.selectionStart = sPos + lastWord.length;
					ifi.selectionEnd = sPos + curWordOrig.length;

					this.insertText(newWord.substr(lastWord.length));

					ifi.selectionStart = sPos + (cnt == 1 ? newWord.length : lastWord.length);
					ifi.selectionEnd = sPos + newWord.length;
				]]>
				</body>
			</method>
			<method name="trimEndSpaces">
				<body>
				<![CDATA[
					const selMarker = "\uffff" + Math.random().toFixed(24).substr(2) + "\uffff";
					var val = this.value;
					var ifi = this.inputField;
					var ss = ifi.selectionStart;
					var se = ifi.selectionEnd;
					var newVal = val.substring(0, ss)
						+ selMarker + val.substring(ss, se) + selMarker
						+ val.substring(se);
					newVal = newVal.replace(new RegExp(<>[ \t]*({selMarker})?[ \t]*({selMarker})?[ \t]*$</>, "mg"), "$1$2");
					ss = newVal.indexOf(selMarker);
					se = newVal.lastIndexOf(selMarker) - selMarker.length;
					newVal = newVal.replace(selMarker, "", "g");
 					if(newVal != val) {
						var sTop = ifi.scrollTop;
						var sLeft = ifi.scrollLeft;
 						this.value = newVal;
 						ifi.scrollTop = sTop;
 						ifi.scrollLeft = sLeft;
 						ifi.selectionStart = ss;
 						ifi.selectionEnd = se;
 						this.fireChange();
 					}
				]]>
				</body>
			</method>

			<method name="fireChange">
				<body>
				<![CDATA[
					var evt = this.ownerDocument.createEvent("Events");
					evt.initEvent("change", true, true);
					this.dispatchEvent(evt);
				]]>
				</body>
			</method>

			<method name="moveCaret">
				<parameter name="moveLeft" />
				<parameter name="event" />
				<body>
				<![CDATA[
					var ifi = this.inputField;
					var ss = ifi.selectionStart;
					var se = ifi.selectionEnd;
					if(ss == se)
						return;
					event.preventDefault();
					ifi.selectionStart = ifi.selectionEnd = moveLeft ? ss : se;
					this.scrollSelectionIntoView();
				]]>
				</body>
			</method>
		</implementation>
		<handlers>
			<handler event="keypress" preventdefault="true" keycode="VK_TAB" action="this.setIndent(this.tabSymbol, false);" />
			<handler event="keypress" preventdefault="true" keycode="VK_TAB" action="this.setIndent(this.tabSymbol, true);" modifiers="shift" />
			<handler event="keypress" preventdefault="true" key=" " action="this.setIndent(' ', false);" />
			<handler event="keypress" preventdefault="true" key=" " action="this.setIndent(' ', true);" modifiers="shift" />
			<handler event="keypress" keycode="VK_BACK" action="this.removeSpaces(event);" />
			<handler event="keypress" preventdefault="true" key="a" action="this.toggleComments(true);" modifiers="control,shift" />
			<handler event="keypress" preventdefault="true" key="q" action="this.toggleComments(false);" modifiers="control,shift" />
			<handler event="keypress" preventdefault="true" keycode="VK_RETURN" action="this.formatNewLine();" />
			<handler event="keypress" preventdefault="true" keycode="VK_F12" action="this.toggleMaximized();" />
			<handler event="keypress" preventdefault="true" key="+" action="this.textZoom(1);" modifiers="control" />
			<handler event="keypress" preventdefault="true" key="-" action="this.textZoom(-1);" modifiers="control" />
			<handler event="keypress" preventdefault="true" key="0" action="this.textZoom(0);" modifiers="control" />
			<handler event="keypress" preventdefault="true" key="g" action="this.goToLine();" modifiers="control" />
			<handler event="keypress" preventdefault="true" key="w" action="this.toggleWordWrap();" modifiers="control" />
			<handler event="keypress" preventdefault="true" key="e" action="this.openExternalEditor();" modifiers="control,shift" />
			<handler event="keypress" preventdefault="true" key=" " action="this.jsAutocomplete(false);" modifiers="control" />
			<handler event="keypress" preventdefault="true" key=" " action="this.jsAutocomplete(true);" modifiers="control,shift" />
			<handler event="keypress" preventdefault="true" keycode="VK_BACK" action="this.trimEndSpaces();" modifiers="alt" />

			<handler event="keypress" keycode="VK_LEFT" action="this.moveCaret(true, event);" />
			<handler event="keypress" keycode="VK_RIGHT" action="this.moveCaret(false, event);" />
			<handler event="blur">
			<![CDATA[
				if(event.originalTarget !== this.inputField || !this.maximized)
					return;
				setTimeout(function(_this) {
					if(document.commandDispatcher.focusedElement !== _this.inputField) // E.g. user press Ctrl+Tab
						_this.maximized = false;
				}, 0, this);
			]]>
			</handler>
			<handler event="dragover">
			<![CDATA[
				if(event.shiftKey)
					return;

				var ex = event.screenX, ey = event.screenY;

				var dragSpeed = 0;
				var now = Date.now();
				if("_dragData" in this) {
					var dd = this._dragData;
					var dt = now - dd.t;
					dragSpeed = dt < 5
						? 100 // Just ignore...
						: Math.pow(Math.pow(dd.x - ex, 2) + Math.pow(dd.y - ey, 2), 0.5)/dt*1000; // px/s
				}
				this._dragData = { t: now, x: ex, y: ey };
				if(dragSpeed > 4)
					return;

				var bo = this.boxObject;
				var minX = bo.screenX, maxX = minX + bo.width;
				var minY = bo.screenY, maxY = minY + bo.height;

				//if(ex < minX || ex > maxX || ey < minY || ey > maxY)
				//	return;

				const corner = 30;

				var c = function(offset) {
					var d = corner - offset;
					return Math.round(Math.min(corner*1.6, d + Math.pow(d, d/corner*1.15) - 1));
				};
				var d, ifi = this.inputField;

				if((d = ex - minX) < corner) // left
					ifi.scrollLeft -= c(d);
				else if((d = maxX - ex) < corner) // right
					ifi.scrollLeft += c(d);

				if((d = ey - minY) < corner) // top
					ifi.scrollTop -= c(d);
				else if((d = maxY - ey) < corner) // bottom
					ifi.scrollTop += c(d);

			]]>
			</handler>
		</handlers>
	</binding>
</bindings>