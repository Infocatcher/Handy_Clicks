<?xml version="1.0"?>
<bindings id="handyClicks-bindings" xmlns="http://www.mozilla.org/xbl">
	<binding id="codeEditor" extends="chrome://global/content/bindings/textbox.xml#textarea">
		<implementation>
			<constructor>
			<![CDATA[
				var ww = -1;
				if(this.hasAttribute("hc_wrapWidth")) {
					var _ww = Number(this.getAttribute("hc_wrapWidth"));
					if(isFinite(_ww))
						ww = _ww;
				}
				try { // Strange bug in Firefox 1.5
					this.editor.wrapWidth = ww;
				}
				catch(e) {
				}
			]]>
			</constructor>
			<property name="tabSymbol">
				<getter>
				<![CDATA[
					return this.getAttribute("hc_tabSymbol")
						|| "handyClicksPrefUtils" in top && top.handyClicksPrefUtils.pref("editor.tabSymbol")
						|| "\t";
				]]>
				</getter>
				<setter>
					this.setAttribute("hc_tabSymbol", val);
				</setter>
			</property>
			<property name="editor" readonly="true">
				<getter>
					return this.inputField // Thanks to Custom Buttons!
						.QueryInterface(Components.interfaces.nsIDOMNSEditableElement)
						.editor
						.QueryInterface(Components.interfaces.nsIPlaintextEditor);
				</getter>
			</property>
			<property name="newValue">
				<setter>
					this.value = val;
					this.editor.transactionManager.clear();
				</setter>
			</property>
			<method name="insertText">
				<parameter name="text" />
				<body>
					if(text)
						this.editor.insertText(text);
					else
						this.editor.deleteSelection(0);
				</body>
			</method>
			<field name="INSERT_SELECT_ALL">0</field>
			<field name="INSERT_MOVE_CURSOR_TO_START">1</field>
			<field name="INSERT_SELECT_CUSTOM">2</field>
			<method name="insertTextEx">
				<parameter name="text" />
				<parameter name="startPos" />
				<parameter name="endPos" />
				<parameter name="selectFlag" />
				<parameter name="selStart" />
				<parameter name="selEnd" />
				<body>
				<![CDATA[
					var ifi = this.inputField;

					var sTop = ifi.scrollTop;
					var sHeight = ifi.scrollHeight;
					var sLeft = ifi.scrollLeft;
					var sWidth = ifi.scrollWidth;

					ifi.selectionStart = startPos;
					ifi.selectionEnd = endPos;

					this.insertText(text);

					switch(selectFlag) {
						case this.INSERT_SELECT_ALL:
							ifi.selectionStart = startPos;
							ifi.selectionEnd = startPos + text.length;
						break;
						case this.INSERT_MOVE_CURSOR_TO_START:
							ifi.selectionStart = startPos;
							ifi.selectionEnd = startPos;
						break;
						case this.INSERT_SELECT_CUSTOM:
							ifi.selectionStart = selStart;
							ifi.selectionEnd = selEnd;
					}
					ifi.scrollTop = sTop + (ifi.scrollHeight - sHeight);
					ifi.scrollLeft = sLeft + (ifi.scrollWidth - sWidth);
				]]>
				</body>
			</method>
			<method name="setIndent">
				<parameter name="indentChar" />
				<parameter name="removeFlag" />
				<body>
				<![CDATA[
					var val = this.value;
					var ifi = this.inputField;

					var startPos = ifi.selectionStart;
					var endPos = ifi.selectionEnd;

					var sel = val.substring(startPos, endPos);
					if(!/\n|\r/.test(sel)) {
						if(removeFlag)
							this.insertTextEx(indentChar, startPos, endPos, this.INSERT_MOVE_CURSOR_TO_START);
						else
							this.insertText(indentChar);
						return;
					}
					var startVal = val.substring(0, startPos);
					var endVal = val.substring(endPos, val.length);

					var selLen = endPos - startPos;
					var startLine = startVal.search(/(^|\n|\r)[^\n\r]*$/);
					startLine += RegExp.$1.length;
					var endLine = startVal.length + selLen + endVal.search(/\r|\n|$/);

					var block = val.substring(startLine, endLine);
					if(removeFlag) {
						if(/^ {2,}$/.test(indentChar))
							indentChar = "( {1," + indentChar.length + "}|\\t)";
						var re = new RegExp("^" + indentChar, "mg");
						if(re.test(block))
							block = block.replace(re, "");
						else
							return;
					}
					else
						block = block.replace(/^/mg, indentChar);
					this.insertTextEx(block, startLine, endLine, this.INSERT_SELECT_ALL);
				]]>
				</body>
			</method>
			<method name="toggleComments">
				<parameter name="onlyInLineStart" />
				<body>
				<![CDATA[
					var val = this.value;
					var ifi = this.inputField;

					var startPos = ifi.selectionStart;
					var endPos = ifi.selectionEnd;

					var sel = val.substring(startPos, endPos);
					var isMultiline = /\n|\r/.test(sel);

					var startVal = val.substring(0, startPos);
					var endVal = val.substring(endPos, val.length);

					var selLen = endPos - startPos;
					var startLine = startVal.search(/(^|\n|\r)[^\n\r]*$/);
					startLine += RegExp.$1.length;
					var endLine = startVal.length + selLen + endVal.search(/\r|\n|$/);

					var block = val.substring(startLine, endLine);
					var bLen0 = block.length;

					if(onlyInLineStart)
						var re = /^\/\//mg, subst = "";
					else
						var re = /^(\s*)\/\//mg, subst = "$1";
					if(re.test(block))
						block = block.replace(re, subst);
					else
						block = block.replace(/^/mg, "//");
					var bLen1 = block.length;

					if(isMultiline)
						this.insertTextEx(block, startLine, endLine, this.INSERT_SELECT_ALL);
					else
						this.insertTextEx(
							block, startLine, endLine,
							this.INSERT_SELECT_CUSTOM,
							startPos + bLen1 - bLen0,
							endPos + bLen1 - bLen0
						);
				]]>
				</body>
			</method>
			<method name="formatNewLine">
				<body>
				<![CDATA[
					var val = this.value;
					var ifi = this.inputField;

					var startPos = ifi.selectionStart;
					var endPos = ifi.selectionEnd;

					var startVal = val.substring(0, startPos);
					var endVal = val.substring(endPos, val.length);

					var startLine = startVal.search(/(^|\n|\r)[^\n\r]*$/);
					startLine += RegExp.$1.length;

					var line = val.substring(startLine, startPos);

					var indent = /^[ \t]+/.test(line) ? RegExp.lastMatch : "";
					this.insertText("\n" + indent);
				]]>
				</body>
			</method>
			<method name="goToLine">
				<body>
				<![CDATA[
					var currLine = this.currentLine;
					var currCol = this.currentColumn;
					var num = { value: currLine + ":" + currCol };
					var ut = "handyClicksUtils" in top && top.handyClicksUtils;
					var ps = Components.classes["@mozilla.org/embedcomp/prompt-service;1"]
						.getService(Components.interfaces.nsIPromptService);
					var res = ps.prompt(
						top,
						ut ? ut.getLocalized("goToLineTitle") : "Go to line\u2026",
						(ut ? ut.getLocalized("goToLineMessage") : "Line number (1 \u2026 %max):")
							.replace("%max", this.linesCount),
						num,
						null, {}
					);
					if(!res)
						return;
					if(!/^(\+|-)?(\d+)(?:\s*[:;,|\/\\_]\s*(\+|-)?(\d+))?$/.test(num.value))
						return;
					var line = Number(RegExp.$2);
					if(RegExp.$1)
						line = Math.max(1, currLine + line*(RegExp.$1 == "+" ? 1 : -1));
					var col = Number(RegExp.$4);
					if(RegExp.$3)
						col = Math.max(0, currCol + col*(RegExp.$3 == "+" ? 1 : -1));
					this.scrollTo(line, col);
				]]>
				</body>
			</method>
			<property name="currentLine" readonly="true">
				<getter>
				<![CDATA[
					return this.value.substring(0, this.inputField.selectionStart).match(/^.*$/mg).length;
				]]>
				</getter>
			</property>
			<property name="currentColumn" readonly="true">
				<getter>
				<![CDATA[
					return this.value.substring(0, this.inputField.selectionStart).match(/[^\n\r]*$/)[0].length + 1;
				]]>
				</getter>
			</property>
			<property name="linesCount" readonly="true">
				<getter>
				<![CDATA[
					//return this.editor.rootElement.getElementsByTagName("br").length;
					return this.value.match(/^.*$/mg).length;
				]]>
				</getter>
			</property>
			<property name="columnsCount" readonly="true">
				<getter>
				<![CDATA[
					// For current line
					return this.value.substr(this.inputField.selectionStart).match(/^[^\n\r]*/)[0].length + 1;
				]]>
				</getter>
			</property>
			<method name="scrollTo">
				<parameter name="lineNumber" />
				<parameter name="columnNumber" />
				<parameter name="allowOverflow" />
				<body>
				<![CDATA[
					if(allowOverflow === undefined)
						allowOverflow = true;
					// Thanks to Custom Buttons!
					if(lineNumber != null && isFinite(lineNumber)) {
						var editor = this.editor;
						var maxLine = this.linesCount;
						if(lineNumber > maxLine && !allowOverflow)
							editor.endOfDocument();
						else {
							lineNumber = Math.min(lineNumber, maxLine);
							editor.beginningOfDocument();
							var sc = editor.selectionController;
							while(--lineNumber > 0)
								sc.lineMove(true, false);
						}
					}
					if(columnNumber != null && isFinite(columnNumber)) {
						var maxCol = this.columnsCount;
						columnNumber = Math.max(1, Math.min(maxCol, columnNumber));
						if(allowOverflow || columnNumber <= maxCol) {
							var ifi = this.inputField;
							ifi.selectionStart = ifi.selectionEnd = ifi.selectionStart - this.currentColumn + columnNumber;
						}
					}
					this.scrollSelectionIntoView();
					this.focus();
				]]>
				</body>
			</method>
			<method name="selectLine">
				<parameter name="lineNumber" />
				<body>
				<![CDATA[
					// Thanks to Custom Buttons!
					this.scrollTo(lineNumber, null, false);
					this.editor.selectionController.intraLineMove(true, true);
					this.focus();
				]]>
				</body>
			</method>
			<method name="scrollSelectionIntoView">
				<body>
				<![CDATA[
					// Thanks to Custom Buttons!
					try {
						var sc = this.editor.selectionController;
						sc.scrollSelectionIntoView(
							sc.SELECTION_NORMAL,
							sc.SELECTION_ANCHOR_REGION,
							true
						);
					}
					catch(e) {
					}
				]]>
				</body>
			</method>
			<property name="maximized">
				<getter>
				<![CDATA[
					return this.getAttribute("hc_maximized") == "true";
				]]>
				</getter>
				<setter>
				<![CDATA[
					var node = this;
					for(; node && "setAttribute" in node; node = node.parentNode) {
						if(val) node.setAttribute("hc_maximized", "true");
						else    node.removeAttribute("hc_maximized");
					}
				]]>
				</setter>
			</property>
			<method name="toggleMaximized">
				<body>
				<![CDATA[
					this.maximized = !this.maximized;
				]]>
				</body>
			</method>
			<method name="textZoom">
				<parameter name="add" />
				<body>
				<![CDATA[
					this.style.fontSize = add == 0
						? ""
						: Math.min(
							36,
							Math.max(
								1,
								parseInt(this.ownerDocument.defaultView.getComputedStyle(this, null).fontSize) + add
							)
						) + "px";
					if(this.id)
						document.persist(this.id, "style");
				]]>
				</body>
			</method>
			<method name="toggleWordWrap">
				<body>
				<![CDATA[
					var ww = this.getAttribute("hc_wrapWidth") == "0" ? -1 : 0;
					this.editor.wrapWidth = ww;
					this.setAttribute("hc_wrapWidth", ww);
					if(this.id)
						document.persist(this.id, "hc_wrapWidth");
				]]>
				</body>
			</method>

			<field name="tempFile">null</field>
			<method name="openExternalEditor">
				<body>
				<![CDATA[
					if(!("handyClicksUtils" in top))
						return;
					var ut = top.handyClicksUtils;
					var file = this.tempFile;
					var isNew = !file || !file.exists();

					if(isNew) {
						var ext = ut.pu.pref("editor.externalEditorExtension") || "js";
						var fName = "handyclicks_" + this.id.replace(/^hc-editor-|Field/g, "") + "." + ext;
						file = ut.getFileByAlias("TmpD");
						file.append(fName);
						file.createUnique(file.NORMAL_FILE_TYPE, 0644);
						this.tempFile = file;

						Components.classes["@mozilla.org/uriloader/external-helper-app-service;1"]
							.getService(Components.interfaces.nsPIExternalAppLauncher)
							.deleteTemporaryFileOnExit(file);
					}

					ut.writeToFile(this.value, file);

					if(isNew) {
						this._lastModifiedTime = file.lastModifiedTime;
						this._fileSize = file.fileSize;

						var _this = this;
						var upd = function(e) {
							var file = _this.tempFile;
							if(!file || !file.exists())
								return;
							var fTime = file.lastModifiedTime;
							var fSize = file.fileSize;
							if(_this._lastModifiedTime == fTime && _this._fileSize == fSize)
								return;
							var fVal = ut.readFromFile(file);
							if(fVal == _this.value)
								return;

							var ifi = _this.inputField;
							var sTop = ifi.scrollTop;
							var sLeft = ifi.scrollLeft;

							_this.value = fVal;

							ifi.scrollTop = sTop;
							ifi.scrollLeft = sLeft;

							_this._lastModifiedTime = fTime;
							_this._fileSize = fSize;
							_this.fade();

							var evt = document.createEvent("Events");
							evt.initEvent("change", true, true);
							_this.dispatchEvent(evt);
						};
						top.addEventListener("focus", upd, false);
						top.addEventListener("unload", function _unl(e) {
							var win = e.target.defaultView;
							if(win !== win.top)
								return;
							win.removeEventListener(e.type, _unl, false);
							win.removeEventListener("focus", upd, false);
							var file = _this.tempFile;
							if(file && file.exists())
								file.remove(false);
						}, false);
					}

					var ee = ut.pu.pref("editor.externalEditorPath");
					if(ee) {
						var args = [file.path];
						var eeArgs = ut.pu.pref("editor.externalEditorArgs");
						if(eeArgs)
							args.push(eeArgs.replace("%L", this.currentLine));
						if(ut.startProcess(ee, args))
							this.fade();
					}
					else {
						//~ todo: association may be "invalid" (like wscript.exe on Windows) or missing
						try {
							file.launch();
							this.fade();
						}
						catch(e) {
							// See https://developer.mozilla.org/en/nsILocalFile#Remarks
							ut._err(e);
						}
					}
				]]>
				</body>
			</method>

			<method name="fade">
				<body>
				<![CDATA[
					const opMax = 1, opMin = 0.5, opDur = 350;
					const opDelay = 10, opStep = (opMax - opMin)*2*opDelay/opDur;

					var op = opMax, sign = -1;
					var st = this.style;

					var opInt = setInterval(
						function() {
							if(op < opMin)
								sign = 1;
							else if(op > opMax) {
								clearInterval(opInt);
								st.opacity = "";
								return;
							}
							st.opacity = op;
							op += sign*opStep;
						},
						opDelay
					);
				]]>
				</body>
			</method>

			<method name="jsAutocomplete">
				<parameter name="reverseFlag" />
				<body>
				<![CDATA[
					var ifi = this.inputField;
					var ss = ifi.selectionStart;
					var se = ifi.selectionEnd;
					var val = this.value;
					var selText = val.substring(ss, se);
					if(selText && !/^[\w$]+['"]?$/.test(selText))
						return;
					var startText = val.substring(0, ss);

					if(!/(?:(\.)\s*|('|"))?([\w$]+)$/.test(startText))
						return;
					var isProp = !!RegExp.$1;
					var isStr = !!RegExp.$2, strComma = RegExp.$2;
					var lastWord = RegExp.$3;

					var scopeProp = isProp
						? "jsProps"
						: isStr
							? "jsStrings"
							: "jsStatements";

					var newWord;
					var curWordOrig = lastWord + selText;
					var curWord = curWordOrig.replace(/['"]$/, "");

					if(!("handyClicksAutocompleteData" in top)) {
						Components.classes["@mozilla.org/moz/jssubscript-loader;1"]
							.getService(Components.interfaces.mozIJSSubScriptLoader)
							.loadSubScript(new Error().fileName.replace(/[^\/]+$/, "") + "editorAutocompleteData.js");
					}
					var scopeArr = top.handyClicksAutocompleteData[scopeProp];
					if(reverseFlag)
						scopeArr = scopeArr.concat().reverse();

					var found = false;
					scopeArr.some(
						function(p) {
							if(!found && p == curWord) {
								found = true;
								return false;
							}
							if(found && p.indexOf(lastWord) == 0) {
								newWord = p;
								return true;
							}
							return false;
						}
					);
					if(!newWord) {
						scopeArr.some(
							function(p) {
								if(p.indexOf(lastWord) == 0) {
									newWord = p;
									return true;
								}
								return false;
							}
						);
					}
					if(!newWord || newWord == curWord)
						return;

					var cnt = 0;
					scopeArr.forEach(
						function(p) {
							if(p.indexOf(lastWord) == 0)
								cnt++;
						}
					);

					if(isStr)
						newWord += strComma;

					var sPos = startText.lastIndexOf(lastWord);
					ifi.selectionStart = sPos + lastWord.length;
					ifi.selectionEnd = sPos + curWordOrig.length;

					this.insertText(newWord.substr(lastWord.length));

					ifi.selectionStart = sPos + (cnt == 1 ? newWord.length : lastWord.length);
					ifi.selectionEnd = sPos + newWord.length;
				]]>
				</body>
			</method>

			<method name="moveCaret">
				<parameter name="moveLeft" />
				<parameter name="event" />
				<body>
				<![CDATA[
					var ifi = this.inputField;
					var ss = ifi.selectionStart;
					var se = ifi.selectionEnd;
					if(ss == se)
						return;
					event.preventDefault();
					ifi.selectionStart = ifi.selectionEnd = moveLeft ? ss : se;
					this.scrollSelectionIntoView();
				]]>
				</body>
			</method>
		</implementation>
		<handlers>
			<handler event="keypress" preventdefault="true" keycode="VK_TAB" action="this.setIndent(this.tabSymbol, false);" />
			<handler event="keypress" preventdefault="true" keycode="VK_TAB" action="this.setIndent(this.tabSymbol, true);" modifiers="shift" />
			<handler event="keypress" preventdefault="true" key=" " action="this.setIndent(' ', false);" />
			<handler event="keypress" preventdefault="true" key=" " action="this.setIndent(' ', true);" modifiers="shift" />
			<handler event="keypress" preventdefault="true" key="a" action="this.toggleComments(true);" modifiers="control,shift" />
			<handler event="keypress" preventdefault="true" key="q" action="this.toggleComments(false);" modifiers="control,shift" />
			<handler event="keypress" preventdefault="true" keycode="VK_RETURN" action="this.formatNewLine();" />
			<handler event="keypress" preventdefault="true" keycode="VK_F12" action="this.toggleMaximized();" />
			<handler event="keypress" preventdefault="true" key="+" action="this.textZoom(1);" modifiers="control" />
			<handler event="keypress" preventdefault="true" key="-" action="this.textZoom(-1);" modifiers="control" />
			<handler event="keypress" preventdefault="true" key="0" action="this.textZoom(0);" modifiers="control" />
			<handler event="keypress" preventdefault="true" key="g" action="this.goToLine();" modifiers="control" />
			<handler event="keypress" preventdefault="true" key="w" action="this.toggleWordWrap();" modifiers="control" />
			<handler event="keypress" preventdefault="true" key="e" action="this.openExternalEditor();" modifiers="control,shift" />
			<handler event="keypress" preventdefault="true" key=" " action="this.jsAutocomplete(false);" modifiers="control" />
			<handler event="keypress" preventdefault="true" key=" " action="this.jsAutocomplete(true);" modifiers="control,shift" />

			<handler event="keypress" keycode="VK_LEFT" action="this.moveCaret(true, event);" />
			<handler event="keypress" keycode="VK_RIGHT" action="this.moveCaret(false, event);" />
			<handler event="blur">
			<![CDATA[
				if(event.originalTarget !== this.inputField || !this.maximized)
					return;
				setTimeout(function(_this) {
					if(document.commandDispatcher.focusedElement !== _this.inputField) // E.g. user press Ctrl+Tab
						_this.maximized = false;
				}, 0, this);
			]]>
			</handler>
			<handler event="dragover">
			<![CDATA[
				if(event.shiftKey)
					return;

				var ex = event.screenX, ey = event.screenY;

				var dragSpeed = 0;
				var now = Date.now();
				if("_dragData" in this) {
					var dd = this._dragData;
					var dt = now - dd.t;
					dragSpeed = dt < 5
						? 100 // Just ignore...
						: Math.pow(Math.pow(dd.x - ex, 2) + Math.pow(dd.y - ey, 2), 0.5)/dt*1000; // px/s
				}
				this._dragData = { t: now, x: ex, y: ey };
				if(dragSpeed > 4)
					return;

				var bo = this.boxObject;
				var minX = bo.screenX, maxX = minX + bo.width;
				var minY = bo.screenY, maxY = minY + bo.height;

				//if(ex < minX || ex > maxX || ey < minY || ey > maxY)
				//	return;

				const corner = 30;

				var c = function(offset) {
					var d = corner - offset;
					return Math.round(Math.min(corner*1.6, d + Math.pow(d, d/corner*1.15) - 1));
				};
				var d, ifi = this.inputField;

				if((d = ex - minX) < corner) // left
					ifi.scrollLeft -= c(d);
				else if((d = maxX - ex) < corner) // right
					ifi.scrollLeft += c(d);

				if((d = ey - minY) < corner) // top
					ifi.scrollTop -= c(d);
				else if((d = maxY - ey) < corner) // bottom
					ifi.scrollTop += c(d);

			]]>
			</handler>
		</handlers>
	</binding>
</bindings>